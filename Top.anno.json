[
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop_1>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top_1",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 13,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top_1",
    "name":"sram_top.v",
    "text":"/* verilator lint_off EOFNEWLINE */\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n  // SRAM interface in\n  input   logic        csb_i,\n  input   logic [11:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n);\n\nlogic        csb;\nlogic [11:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(posedge clk_i) begin\n  if (rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  .ADDR_WIDTH (13),\n  .RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0),  // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n  .clk0(clk_i),\n  .csb0(csb_i),\n  .web0(we_i),\n  .wmask0(wmask_i),\n  .addr0(addr_i),\n  .din0(wdata_i),\n  .dout0(rdata_o),\n  .clk1('0),\n  .csb1('1),\n  .addr1('0),\n  .dout1()\n);\n\nalways_ff @(posedge clk_i) begin\n  if (rst_i) begin\n    rvalid <= 1'b0;\n  end else if (!we_i) begin\n    rvalid <= 1'b0;\n  end else if (!csb_i && we_i) begin\n    rvalid <= 1'b1;\n  end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 13,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top",
    "name":"sram_top.v",
    "text":"/* verilator lint_off EOFNEWLINE */\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n  // SRAM interface in\n  input   logic        csb_i,\n  input   logic [11:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n);\n\nlogic        csb;\nlogic [11:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(posedge clk_i) begin\n  if (rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  .ADDR_WIDTH (13),\n  .RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0),  // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n  .clk0(clk_i),\n  .csb0(csb_i),\n  .web0(we_i),\n  .wmask0(wmask_i),\n  .addr0(addr_i),\n  .din0(wdata_i),\n  .dout0(rdata_o),\n  .clk1('0),\n  .csb1('1),\n  .addr1('0),\n  .dout1()\n);\n\nalways_ff @(posedge clk_i) begin\n  if (rst_i) begin\n    rvalid <= 1'b0;\n  end else if (!we_i) begin\n    rvalid <= 1'b0;\n  end else if (!csb_i && we_i) begin\n    rvalid <= 1'b1;\n  end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Execute>f7_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Execute>io_stall"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_MISA_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_MHARTID_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_opr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_o_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_addr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_w_en"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_nx"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_uf"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_of"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_dz"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_nv"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_frm"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"."
  }
]